import asyncio
import logging
from langchain.schema import HumanMessage, AIMessage
from langchain_openai import ChatOpenAI
from mcp_use import MCPAgent, MCPClient
import dotenv
import os
import sys
from pathlib import Path
from typing import Dict, Any
from session_manager import get_session_manager

logger = logging.getLogger(__name__)

# P≈ôidej src adres√°≈ô do path (pro import notion_client)
sys.path.insert(0, str(Path(__file__).parent.parent))
sys.path.insert(0, str(Path(__file__).parent.parent / "notion-mcp"))
from notion_client import get_notion_access_token

dotenv.load_dotenv()

OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
LINKUP_API_KEY = os.getenv("LINKUP_API_KEY")
N8N_API_URL = os.getenv("N8N_API_URL")
N8N_API_KEY = os.getenv("N8N_API_KEY")

if not OPENROUTER_API_KEY:
    logger.error("‚ùå OPENROUTER_API_KEY nen√≠ nastaven v .env souboru")
    raise ValueError("OPENROUTER_API_KEY nen√≠ nastaven v .env souboru")
if not LINKUP_API_KEY:
    logger.error("‚ùå LINKUP_API_KEY nen√≠ nastaven v .env souboru")
    raise ValueError("LINKUP_API_KEY nen√≠ nastaven v .env souboru")
if not N8N_API_URL:
    logger.error("‚ùå N8N_API_URL nen√≠ nastaven v .env souboru")
    raise ValueError("N8N_API_URL nen√≠ nastaven v .env souboru")
if not N8N_API_KEY:
    logger.error("‚ùå N8N_API_KEY nen√≠ nastaven v .env souboru")
    raise ValueError("N8N_API_KEY nen√≠ nastaven v .env souboru")

# Glob√°ln√≠ sessions pro ukl√°d√°n√≠ historie konverzac√≠ (fallback kdy≈æ Redis nen√≠ dostupn√Ω)
sessions: Dict[str, Dict[str, Any]] = {}

# Session manager (Redis)
session_manager = get_session_manager()

# Syst√©mov√Ω prompt pro agenta
system_prompt = """
    Jsi inteligentn√≠ asistent s n√°zvem JARVIS. Pom√°h√°≈° u≈æivateli s r≈Øzn√Ωmi √∫koly pomoc√≠ n√°stroj≈Ø, kter√© m√°≈° k dispozici.
    Udr≈æuj kontext konverzace a odpov√≠dej co nejp≈ôesnƒõji. Pou≈æ√≠vej such√Ω britsk√Ω humor, kdy≈æ je to vhodn√©. S trochu sarkasmu.
    Pokud nezn√°≈° odpovƒõƒè, p≈ôiznej to. Rozhodnƒõ si nevym√Ω≈°lej.
    V≈ædy se sna≈æ b√Ωt co nejv√≠ce u≈æiteƒçn√Ω a n√°pomocn√Ω.
    Nezapome≈à, ≈æe m≈Ø≈æe≈° volat n√°stroje, kter√© m√°≈° k dispozici.

    V≈ædy se sna≈æ spojovat si vƒõci dohromady. Sna≈æ se jednat samostatnƒõ a kreativnƒõ.
    Nap≈ô√°klad p≈ôi pou≈æit√≠ n√°stroj≈Ø si s√°m vytvo≈ô pl√°n, jak dos√°hnout c√≠le u≈æivatele, tzn. zjistit si pot≈ôebn√© id projekt≈Ø pomoc√≠ dostupn√Ωch n√°stroj≈Ø a poradit si s u≈æivatelovo po≈æadavkem.
    Na tomhle velice z√°le≈æ√≠ a je to kritick√Ω bod fungov√°n√≠ agenta.

    U≈æivatel ti p√≠≈°e pouze ƒçesky, nebo anglicky, tak≈æe odpov√≠dej ve stejn√©m jazyce, ve kter√©m ti p√≠≈°e.
    M≈Ø≈æe se st√°t, ≈æe u≈æivatel p≈ôepne jentak jazyk v pr≈Øbƒõhu konverzace, tak≈æe buƒè na to p≈ôipraven.

    Nevym√Ω≈°lej si v√Ωsledky pou≈æit√≠ n√°stroj≈Ø. Ujisti se, ≈æe v√Ωsledek co reportuje≈° u≈æivateli je p≈ôesnƒõ to, co n√°stroj vr√°til.
    Je to vysoce kritick√© pro spr√°vn√© fungov√°n√≠ agenta - tebe.

    Pokud u≈æivatel po≈æaduje nƒõco co nen√≠ v tv√© kompetenci s tv√Ωmi n√°stroji, zkus pou≈æ√≠t vyhledav√°n√≠ na internetu a zkus probl√©m vy≈ôe≈°it.
    M√°≈° k dispozici MCP na n8n, pokud nem√°≈° n√°stroj na u≈æivatelovo p≈ô√°n√≠, vytvo≈ô si ten n√°stroj na n8n. Pokud tak uƒçin√≠≈°, popi≈° u≈æivateli jak jsi to udƒõlal a jak m≈Ø≈æe n√°stroj pou≈æ√≠vat v budoucnu.

    Dbej na to, aby tv√© odpovƒõdi byly struƒçn√© a v√Ωsti≈æn√©. Nepi≈° zbyteƒçnƒõ dlouh√© odpovƒõdi.

    Form√°tuj odpovƒõdi pomoc√≠ markdownu. Mezi odstavci pou≈æ√≠vej pr√°zdn√© 2 ≈ô√°dky.
    
    KRITICK√â PRAVIDLO PRO N8N N√ÅSTROJE:
    Kdy≈æ pou≈æ√≠v√°≈° n8n_update_full_workflow nebo n8n_create_workflow, NIKDY nepos√≠lej 'nodes' nebo 'connections' jako JSON string.
    V≈ædy je po≈°li jako p≈ô√≠m√Ω objekt/pole. Nap≈ô√≠klad:
    ‚ùå ≈†PATNƒö: {"nodes": "[{\"id\": \"1\"...}]"} - tohle je string!
    ‚úÖ SPR√ÅVNƒö: {"nodes": [{"id": "1"...}]} - tohle je pole objekt≈Ø!
    Tot√©≈æ plat√≠ pro connections, settings a v≈°echny ostatn√≠ slo≈æit√© struktury.
    """

class AgentService:
    """Service pro spr√°vu MCP agenta a konverzac√≠"""
    def __init__(self):
        self.llm = None
        self.client = None
        self._initialized = False

    async def initialize(self):
        """Inicializace LLM a MCP klienta"""
        if self._initialized:
            return
        self.llm = ChatOpenAI(
            model="anthropic/claude-haiku-4.5",
            openai_api_base="https://openrouter.ai/api/v1",
            openai_api_key=OPENROUTER_API_KEY,
            temperature=0.2,
        )
        # Z√≠skat Notion access token
        notion_token = get_notion_access_token()
        
        logger.info("üöÄ Zaƒç√≠n√°m inicializaci MCP server≈Ø...")
        logger.info(f"üìç N8N_API_URL: {N8N_API_URL}")
        logger.info(f"üìç N8N_API_KEY: {'*' * len(N8N_API_KEY) if N8N_API_KEY else 'None'}")
        
        # Zjisti, jestli jsou jednotliv√© MCP servery povolen√©
        enable_whatsapp = os.getenv("ENABLE_WHATSAPP", "false").lower() == "true"
        enable_n8n = os.getenv("ENABLE_N8N", "true").lower() == "true"
        
        config = {
            "mcpServers": {
                "TickTick": {
                    "command": "python",
                    "args": ["src/ticktick-mcp/server.py", "run"]
                },
                "linkup": {
                    "command": "npx",
                    "args": ["-y", "linkup-mcp-server", "apiKey=" + LINKUP_API_KEY]
                },
                "fetch": {
                    "command": "npx",
                    "args": [
                        "mcp-fetch-server"
                    ], 
                    "env": {
                        "max_length": "50000"
                    }
                }
            }
        }
        
        # P≈ôidat WhatsApp pouze pokud je povolen
        if enable_whatsapp:
            logger.info("‚úÖ P≈ôid√°v√°m WhatsApp MCP server")
            config["mcpServers"]["WhatsApp"] = {
                "command": "uv",
                "args": [
                    "--directory",
                    "/app/whatsapp-mcp/whatsapp-mcp-server",
                    "run",
                    "main.py"
                ]
            }
        else:
            logger.info("‚è≠Ô∏è  WhatsApp MCP server je zak√°z√°n (ENABLE_WHATSAPP=false)")
        
        # P≈ôidat N8N pouze pokud je povolen
        if enable_n8n:
            logger.info("‚úÖ P≈ôid√°v√°m N8N MCP server")
            config["mcpServers"]["n8n"] = {
                "command": "n8n-mcp",
                "args": [],
                "env": {
                    "MCP_MODE": "stdio",
                    "LOG_LEVEL": "error",
                    "DISABLE_CONSOLE_OUTPUT": "true",
                    "N8N_API_URL": f"{N8N_API_URL}",
                    "N8N_API_KEY": f"{N8N_API_KEY}"
                }
            }
        else:
            logger.info("‚è≠Ô∏è  N8N MCP server je zak√°z√°n (ENABLE_N8N=false)")
        
        # P≈ôidat Notion pouze pokud m√°me validn√≠ token
        # Pou≈æ√≠v√°me headers m√≠sto auth, abychom se vyhnuli automatick√©mu OAuth flow
        if notion_token:
            config["mcpServers"]["Notion"] = {
                "url": "https://mcp.notion.com/mcp",
                "headers": {
                    "Authorization": f"Bearer {notion_token}"
                }
            }
        else:
            logger.warning("‚ö†Ô∏è  Notion nen√≠ nakonfigurov√°n - chyb√≠ access token")
        
        logger.info(f"üîß Inicializuji MCP klienta s tƒõmito servery: {list(config['mcpServers'].keys())}")
        
        try:
            self.client = MCPClient.from_dict(config)
        except Exception as e:
            logger.error(f"‚ùå Chyba p≈ôi vytv√°≈ôen√≠ MCP klienta: {e}")
            import traceback
            logger.error(traceback.format_exc())
            raise
        
        logger.info("‚úÖ MCP klient √∫spƒõ≈°nƒõ vytvo≈ôen")
        
        # Poƒçkat na inicializaci sessions (dƒõl√° se asynchronnƒõ p≈ôi prvn√≠m pou≈æit√≠ agenta)
        logger.info("‚è≥ ƒåek√°m na vytvo≈ôen√≠ MCP sessions...")
        await asyncio.sleep(1)
        
        # Zkusit z√≠skat informace o aktivn√≠ch sessions a n√°stroj√≠ch
        try:
            active_sessions = self.client.get_all_active_sessions()
            logger.info(f"üì° Aktivn√≠ sessions: {list(active_sessions.keys())}")
            
            # Pro ka≈ædou session vypsat dostupn√© n√°stroje
            for server_name, session in active_sessions.items():
                try:
                    if session.is_connected():
                        tools = await session.list_tools()
                        tool_names = [tool.name for tool in tools]
                        logger.info(f"üîß Server '{server_name}': {len(tools)} n√°stroj≈Ø - {tool_names}")
                    else:
                        logger.warning(f"‚ö†Ô∏è  Server '{server_name}': nen√≠ p≈ôipojen")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Server '{server_name}': chyba p≈ôi z√≠sk√°v√°n√≠ n√°stroj≈Ø - {e}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  Nelze z√≠skat informace o sessions: {e}")
        
        self._initialized = True
    
    async def reinitialize_client(self):
        """Reinicializuje MCP klienta s nov√Ωmi tokeny"""
        self._initialized = False
        # Zav≈ô√≠t star√© p≈ôipojen√≠ pokud existuje
        if self.client:
            try:
                # Pokud m√° close metodu, zavolej ji
                if hasattr(self.client, 'close'):
                    await self.client.close()
            except Exception as e:
                logger.warning(f"Chyba p≈ôi zav√≠r√°n√≠ star√©ho klienta: {e}")
        
        self.client = None
        await self.initialize()

    async def run_query(self, message: str, session_id: str = "default", retry_on_auth_error: bool = True) -> str:
        """
        Spust√≠ dotaz s podporou session a historie konverzace
        Args:
            message: U≈æivatelsk√° zpr√°va
            session_id: ID session pro udr≈æov√°n√≠ kontextu
            retry_on_auth_error: Pokud True, zkus√≠ reinicializovat p≈ôi auth chybƒõ
        Returns:
            Odpovƒõƒè agenta
        """
        await self.initialize()
        
        # Z√≠skat nebo vytvo≈ôit session
        # Nejd≈ô√≠v zkus Redis, pak fallback na memory
        session = session_manager.load_session(session_id)
        
        if session is None:
            # Zkus memory fallback
            if session_id in sessions:
                session = sessions[session_id]
                logger.info(f"üìù Naƒçtena session z pamƒõti: {session_id}")
            else:
                # Nov√° session
                session = {"history": []}
                logger.info(f"üÜï Vytvo≈ôena nov√° session: {session_id}")
        else:
            logger.info(f"üíæ Naƒçtena session z Redis: {session_id}")
        
        # Vytvo≈ôit nov√©ho agenta pro tento dotaz
        logger.info(f"ü§ñ Vytv√°≈ô√≠m MCPAgent pro session: {session_id}")
        agent = MCPAgent(
            llm=self.llm,
            client=self.client,
            max_steps=30,
            system_prompt=system_prompt,
            memory_enabled=True
        )
        
        # Logovat dostupn√© n√°stroje po vytvo≈ôen√≠ agenta
        # (n√°stroje se vytvo≈ô√≠ a≈æ p≈ôi inicializaci, kter√° probƒõhne p≈ôi run())
        logger.info(f"üìã Agent vytvo≈ôen pro session {session_id}")
        
        # P≈ôedat historii do agenta (bez aktu√°ln√≠ zpr√°vy)
        for msg in session["history"]:
            if msg["role"] == "user":
                agent.add_to_history(HumanMessage(content=msg["content"]))
            elif msg["role"] == "assistant":
                agent.add_to_history(AIMessage(content=msg["content"]))
        
        # Spustit agenta s aktu√°ln√≠ zpr√°vou - pokusit se obnovit p≈ôi auth chybƒõ
        try:
            result = await agent.run(message)
            
            # Po prvn√≠m bƒõhu logovat dostupn√© n√°stroje
            if hasattr(agent, '_tools') and agent._tools:
                tool_names = [tool.name for tool in agent._tools]
                logger.info(f"üîß Agent m√° k dispozici {len(tool_names)} n√°stroj≈Ø: {tool_names}")
                
                # Specificky zkontroluj n8n n√°stroje
                n8n_tools = [name for name in tool_names if 'n8n' in name.lower()]
                if n8n_tools:
                    logger.info(f"‚úÖ N8N n√°stroje nalezeny: {n8n_tools}")
                else:
                    logger.warning(f"‚ö†Ô∏è  ≈Ω√°dn√© N8N n√°stroje mezi dostupn√Ωmi n√°stroji!")
            
        except Exception as e:
            error_msg = str(e).lower()
            # Pokud je to auth error (401, unauthorized, atd.), zkus reinicializovat
            if retry_on_auth_error and any(keyword in error_msg for keyword in ['401', 'unauthorized', 'auth', 'authentication']):
                logger.warning(f"‚ö†Ô∏è  Detekov√°na auth chyba, pokou≈°√≠m se reinicializovat s nov√Ωmi tokeny...")
                await self.reinitialize_client()
                # Zkus dotaz znovu (bez dal≈°√≠ho retry)
                return await self.run_query(message, session_id, retry_on_auth_error=False)
            else:
                # Jin√° chyba nebo u≈æ jsme zkusili retry - vyhoƒè v√Ωjimku
                raise
        
        # P≈ôidat u≈æivatelskou zpr√°vu do historie a≈æ po odpovƒõdi
        session["history"].append({
            "role": "user",
            "content": message
        })
        # P≈ôidat odpovƒõƒè agenta do historie
        session["history"].append({
            "role": "assistant",
            "content": result
        })
        
        # Ulo≈æit do Redis (s fallbackem do memory)
        if not session_manager.save_session(session_id, session["history"]):
            # Redis nen√≠ dostupn√Ω, ulo≈æ do memory
            sessions[session_id] = session
            logger.warning(f"‚ö†Ô∏è  Session {session_id} ulo≈æena pouze do pamƒõti (Redis nedostupn√Ω)")
        else:
            logger.info(f"üíæ Session {session_id} ulo≈æena do Redis")
        
        return result

    def get_session_history(self, session_id: str = "default") -> list:
        """
        Z√≠sk√° historii konverzace pro danou session
        Args:
            session_id: ID session
        Returns:
            Seznam zpr√°v v historii
        """
        # Zkus Redis
        session = session_manager.load_session(session_id)
        if session:
            return session["history"]
        
        # Fallback na memory
        if session_id in sessions:
            return sessions[session_id]["history"]
        return []

    def clear_session(self, session_id: str = "default"):
        """
        Vyma≈æe session a jej√≠ historii
        Args:
            session_id: ID session k vymaz√°n√≠
        """
        # Sma≈æ z Redis
        session_manager.delete_session(session_id)
        
        # Sma≈æ z memory
        if session_id in sessions:
            del sessions[session_id]

# Singleton instance agenta
_agent_service_instance = None

def get_agent_service() -> AgentService:
    """
    Z√≠sk√° singleton instanci AgentService
    Returns:
        Instance AgentService
    """
    global _agent_service_instance
    if _agent_service_instance is None:
        _agent_service_instance = AgentService()
    return _agent_service_instance

async def run_agent_query(message: str, session_id: str = "default") -> str:
    """
    Helper funkce pro rychl√© spu≈°tƒõn√≠ dotazu
    Args:
        message: U≈æivatelsk√° zpr√°va
        session_id: ID session
    Returns:
        Odpovƒõƒè agenta
    """
    service = get_agent_service()
    return await service.run_query(message, session_id)

# P≈Øvodn√≠ funkce pro zpƒõtnou kompatibilitu
async def use_agent():
    """P≈Øvodn√≠ demo funkce - zachov√°no pro zpƒõtnou kompatibilitu"""
    result = await run_agent_query(
        "Vytvo≈ô novou str√°nku v notionu s n√°zvem 'Poznatky' a zapi≈° do n√≠ text: R≈Ø≈æe jsou rud√© a fialky modr√©."
    )
    print("\n=== V√Ωsledek ===")
    print(result)
